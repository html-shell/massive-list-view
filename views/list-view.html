<!DOCTYPE html>

<button>
Do test
</button>
<div class="ListViewPanel" flex='1'>
  <div class='MassiveListView'>
    <div class='ScrollArea DisplayColumn'>
      <div class='Top' ></div>
      <div class='Items'>
      </div>
      <div flex='1'></div>
    </div>
  </div>
</div>


<script src='../javascripts/size-balanced-tree.js'></script>

<script >
'use strict'

/**
 * Returns a random integer between min (inclusive) and max (inclusive)
 * Using Math.round() will give you a non-uniform distribution!
 */
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

let initListView = function () {
  /*
    Node.selectState
    0: the current Node's subtree are all unselected.
    1: the current Node's subtree are all selected.
    2: the current Node's subtree are partially selected, and the current Node are unselected.
    3: the current Node's subtree are partially selected, and the current Node are selected.

    The selectState always goes top-down ways. That means:
    When a Node has been decided as 'selected' or 'unselected' in the ANCESTOR Node,
    then we have no need to navigate down to check THE node's selectState.
  */
  var Node = function () {
    window.NodeConstructor.apply(this, arguments);
    this.rowTotalHeight = this.value.rowHeight
    this.selectState = 0
  }

  Node.prototype.updateSize = function() {
    window.updateSize.call(this)
    this.rowTotalHeight = this.left.rowTotalHeight + this.right.rowTotalHeight + this.value.rowHeight
  }

  var Nil = window.createNil(Node, {rowHeight: 0})
  var SBTree = window.CreateSBTreeClass(Node, Nil, window.updateChild)
  var NewSBTree = function(){
    SBTree.call(this)
  }

  NewSBTree.prototype = Object.create(SBTree.prototype); // See note below
  NewSBTree.prototype.constructor = NewSBTree
  function updateNode (node) {
    while (node !== Nil) {
      node.updateSize()
      node = node.parent
    }
  }
  NewSBTree.prototype.insertLeafNode = updateNode
  NewSBTree.prototype.removeLeafNode = updateNode
  NewSBTree.prototype.findRowForScrollTop = function (scrollTop) {
    if (this.root.rowTotalHeight === 0) {
      return 0
    }

    if (scrollTop < 0) {
      scrollTop = 0
    } else if (scrollTop >= this.root.rowTotalHeight) {
      scrollTop = this.root.rowTotalHeight - 1
    }
    let node = this.root;
    while (true) {
      if (node.left.rowTotalHeight > scrollTop) {
        node = node.left
      } else {
        scrollTop -= node.left.rowTotalHeight
        if (scrollTop < node.value.rowHeight) {
          break
        }
        scrollTop -= node.value.rowHeight
        node = node.right
      }
    }
    return this.getIndex(node)
  }

  let tree = new NewSBTree()

  const startTime = Date.now()
  let key = 0
  for (let i = 0; i < 500000; ++i) {
    const newItem = {
      rowHeight:getRandomInt(10, 10),
      data: i,
      key: key
    }
    key += 1
    tree.push(newItem)
  }
  console.log(`totalHeight: ${tree.root.rowTotalHeight} ${Date.now() - startTime}`)
  const listView = document.querySelector('.MassiveListView')
  const scrollArea = document.querySelector('.MassiveListView .ScrollArea')
  scrollArea.style.height = tree.root.rowTotalHeight.toString() + 'px'
  const scrollAreaTop = document.querySelector('.MassiveListView > .ScrollArea > .Top')
  listView.onscroll = (event)=> {
    const startTime = Date.now()
    const listHeight = listView.clientHeight
    const scrollTop = listView.scrollTop
    let nodeStartIndex = tree.findRowForScrollTop(scrollTop - listHeight - 1080)
    let nodeEndIndex = tree.findRowForScrollTop(scrollTop + listHeight + listHeight + 1080)
    console.log(`${scrollTop} ${nodeStartIndex} ${nodeEndIndex} ${Date.now() - startTime} ${listHeight}`)
    //scrollAreaTop.style.height = listView.scrollTop + 'px'
  }
}

initListView()

</script>

<style>

html{
  height: 100%;
}

body {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

.ListViewPanel {
  width:200px;
}

.MassiveListView {
  position: absolute;
  top: 0;
  right:0;
  bottom: 0;
  left: 0;
  overflow-y: auto;
}
.MassiveListView > .ScrollArea {
}

.ScrollArea > .Top {
}

.ItemA {
  height: 10px;
  background: #008800;
}

.ItemB {
  height: 20px;
  background: #003399;
}

.ItemC {
  height: 30px;
  background: #993300;
}

.DisplayRow {
  display: flex;
  flex-flow: row nowrap;
}
.DisplayColumn {
  display: flex;
  flex-flow: column nowrap;
}
/*set flex property for items in the box*/
.DisplayRow > [flex="1"],
.DisplayColumn > [flex="1"]
{
  position: relative;
  flex: auto; /* flex-grow: 1; flex-shrink: 1; flex-basis: auto; */
}
.DisplayRow > [flex="0"],
.DisplayColumn > [flex="0"]
{
  flex: none; /* flex-grow: 0; flex-shrink: 0; flex-basis: auto; */
}


</style>
